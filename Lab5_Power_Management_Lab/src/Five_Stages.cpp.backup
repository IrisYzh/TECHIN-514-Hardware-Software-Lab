#define ENABLE_USER_AUTH
#define ENABLE_DATABASE

#include <Arduino.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <FirebaseClient.h>
#include "secrets.h"

// -------------------- Configuration --------------------
static const uint32_t STAGE_DURATION_MS = 11000;      // Each stage: 11 seconds
static const uint32_t WIFI_CONNECT_TIMEOUT_MS = 5000;

// HC-SR04 Pins for XIAO ESP32-C3
static const int PIN_TRIG = 2;  // D0
static const int PIN_ECHO = 3;  // D1

// RTC Memory (persists through deep sleep)
RTC_DATA_ATTR uint8_t g_stage = 0;           // Current stage: 0-4
RTC_DATA_ATTR uint32_t g_cycle_count = 0;    // Total cycles completed

// -------------------- Firebase Objects --------------------
UserAuth user_auth(FIREBASE_API_KEY, FIREBASE_USER_EMAIL, FIREBASE_USER_PASSWORD);
FirebaseApp app;
WiFiClientSecure ssl_client1, ssl_client2;
using AsyncClient = AsyncClientClass;
AsyncClient async_client1(ssl_client1), async_client2(ssl_client2);
RealtimeDatabase Database;
AsyncResult dbResult;

static bool firebaseInitialized = false;

// -------------------- Helper Functions --------------------

void processData(AsyncResult &aResult) {
  if (!aResult.isResult()) return;

  if (aResult.isEvent())
    Firebase.printf("Event: %s, msg: %s, code: %d\n", 
                    aResult.uid().c_str(), 
                    aResult.eventLog().message().c_str(), 
                    aResult.eventLog().code());

  if (aResult.isError())
    Firebase.printf("Error: %s, msg: %s, code: %d\n", 
                    aResult.uid().c_str(), 
                    aResult.error().message().c_str(), 
                    aResult.error().code());

  if (aResult.available())
    Firebase.printf("Success: %s, payload: %s\n", 
                    aResult.uid().c_str(), 
                    aResult.c_str());
}

void wifiOff() {
  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);
  Serial.println("WiFi: OFF");
}

bool wifiOnAndConnect() {
  Serial.println("WiFi: Connecting...");
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  uint32_t startTime = millis();
  while (WiFi.status() != WL_CONNECTED && (millis() - startTime) < WIFI_CONNECT_TIMEOUT_MS) {
    delay(100);
    Serial.print(".");
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println();
    Serial.printf("WiFi: Connected! IP: %s\n", WiFi.localIP().toString().c_str());
    return true;
  } else {
    Serial.println();
    Serial.println("WiFi: Connection timeout");
    return false;
  }
}

void initFirebaseIfNeeded() {
  if (firebaseInitialized) return;

  Serial.println("Firebase: Initializing...");
  
  ssl_client1.setInsecure();
  ssl_client2.setInsecure();
  ssl_client1.setHandshakeTimeout(10);
  ssl_client2.setHandshakeTimeout(10);

  initializeApp(async_client1, app, getAuth(user_auth), processData, "authTask");
  app.getApp<RealtimeDatabase>(Database);
  Database.url(FIREBASE_RTDB_URL);

  firebaseInitialized = true;
  Serial.println("Firebase: Initialized");
}

float ultrasonicReadCm() {
  pinMode(PIN_TRIG, OUTPUT);
  pinMode(PIN_ECHO, INPUT);

  digitalWrite(PIN_TRIG, LOW);
  delayMicroseconds(2);
  digitalWrite(PIN_TRIG, HIGH);
  delayMicroseconds(10);
  digitalWrite(PIN_TRIG, LOW);

  uint32_t duration = pulseIn(PIN_ECHO, HIGH, 30000);
  if (duration == 0) return -1.0f;

  float cm = duration / 58.2f;
  return cm;
}

void waitWithCountdown(uint32_t durationMs) {
  uint32_t startTime = millis();
  uint32_t lastPrint = startTime;
  
  while (millis() - startTime < durationMs) {
    if (millis() - lastPrint >= 1000) {
      uint32_t remaining = (durationMs - (millis() - startTime)) / 1000;
      Serial.printf("Time remaining: %u seconds\n", remaining);
      lastPrint = millis();
    }
    delay(50);
  }
}

void printStageHeader(const char* stageName, uint8_t stageNum, const char* powerEstimate) {
  Serial.println("\n========================================");
  Serial.printf("CYCLE #%u | STAGE %u: %s\n", g_cycle_count, stageNum, stageName);
  Serial.printf("Power: %s\n", powerEstimate);
  Serial.println("========================================");
}

// -------------------- Stage 0: Deep Sleep --------------------
void stageDeepSleep() {
  printStageHeader("DEEP SLEEP", 0, "~10-20 uA");
  Serial.println("Entering deep sleep for 11 seconds");
  
  g_stage = 1;
  
  esp_sleep_enable_timer_wakeup((uint64_t)STAGE_DURATION_MS * 1000ULL);
  
  Serial.println("Deep sleep starting...");
  Serial.flush();
  
  esp_deep_sleep_start();
}

// -------------------- Stage 1: Idle --------------------
void stageIdle() {
  printStageHeader("IDLE", 1, "~40-80 mA");
  Serial.println("CPU active, minimal work, WiFi OFF");
  
  wifiOff();
  
  uint32_t loopCounter = 0;
  uint32_t startTime = millis();
  uint32_t lastPrint = startTime;
  
  while (millis() - startTime < STAGE_DURATION_MS) {
    loopCounter++;
    
    if (millis() - lastPrint >= 1000) {
      uint32_t remaining = (STAGE_DURATION_MS - (millis() - startTime)) / 1000;
      Serial.printf("Idle iterations: %u | Time remaining: %u seconds\n", 
                    loopCounter, remaining);
      lastPrint = millis();
    }
    
    delay(50);
  }
  
  Serial.printf("Stage complete. Total iterations: %u\n", loopCounter);
  g_stage = 2;
}

// -------------------- Stage 2: Ultrasonic Only --------------------
void stageUltrasonicOnly() {
  printStageHeader("ULTRASONIC READINGS", 2, "~50-100 mA");
  Serial.println("Reading sensor continuously, WiFi OFF");
  
  wifiOff();
  
  uint32_t readingCount = 0;
  float sumDistance = 0;
  float minDistance = 9999;
  float maxDistance = 0;
  
  uint32_t startTime = millis();
  uint32_t lastPrint = startTime;
  
  while (millis() - startTime < STAGE_DURATION_MS) {
    float distance = ultrasonicReadCm();
    
    if (distance > 0) {
      readingCount++;
      sumDistance += distance;
      
      if (distance < minDistance) minDistance = distance;
      if (distance > maxDistance) maxDistance = distance;
      
      Serial.printf("Reading #%u: %.2f cm\n", readingCount, distance);
    } else {
      Serial.println("Sensor: No echo");
    }
    
    if (millis() - lastPrint >= 1000) {
      uint32_t remaining = (STAGE_DURATION_MS - (millis() - startTime)) / 1000;
      Serial.printf("Time remaining: %u seconds\n", remaining);
      lastPrint = millis();
    }
    
    delay(500);
  }
  
  if (readingCount > 0) {
    Serial.println("\n--- Statistics ---");
    Serial.printf("Total readings: %u\n", readingCount);
    Serial.printf("Average: %.2f cm\n", sumDistance / readingCount);
    Serial.printf("Min: %.2f cm | Max: %.2f cm\n", minDistance, maxDistance);
  }
  
  g_stage = 3;
}

// -------------------- Stage 3: WiFi Only --------------------
void stageWiFiNoUltrasonic() {
  printStageHeader("WiFi ACTIVE", 3, "~80-170 mA");
  Serial.println("WiFi ON, no sensor readings");
  
  bool wifiConnected = wifiOnAndConnect();
  
  if (wifiConnected) {
    Serial.println("Maintaining WiFi connection...");
    
    uint32_t startTime = millis();
    uint32_t lastCheck = 0;
    uint32_t lastPrint = 0;
    
    while (millis() - startTime < STAGE_DURATION_MS) {
      // WiFi status check every 2 seconds
      if (millis() - lastCheck > 2000) {
        Serial.printf("WiFi Status: Connected | RSSI: %d dBm\n", WiFi.RSSI());
        lastCheck = millis();
      }
      
      // Time remaining print every 1 second
      if (millis() - lastPrint >= 1000) {
        uint32_t remaining = (STAGE_DURATION_MS - (millis() - startTime)) / 1000;
        Serial.printf("Time remaining: %u seconds\n", remaining);
        lastPrint = millis();
      }
      
      delay(50);
    }
  } else {
    Serial.println("WiFi unavailable, waiting anyway...");
    waitWithCountdown(STAGE_DURATION_MS);
  }
  
  g_stage = 4;
}

// -------------------- Stage 4: Full Operation --------------------
void stageFullOperation() {
  printStageHeader("FULL OPERATION", 4, "~160-260 mA");
  Serial.println("All systems: WiFi + Sensor + Firebase");
  
  bool wifiConnected = wifiOnAndConnect();
  if (!wifiConnected) {
    Serial.println("ERROR: WiFi failed, skipping Firebase");
    g_stage = 0;
    g_cycle_count++;
    return;
  }
  
  initFirebaseIfNeeded();
  
  Serial.println("Waiting for Firebase authentication...");
  uint32_t authStart = millis();
  while (!app.ready() && (millis() - authStart) < 8000) {
    app.loop();
    delay(20);
  }
  
  if (!app.ready()) {
    Serial.println("ERROR: Firebase authentication timeout");
    g_stage = 0;
    g_cycle_count++;
    return;
  }
  
  Serial.println("Firebase: Ready!");
  
  // Read sensor
  float distance = ultrasonicReadCm();
  uint32_t timestamp = millis();
  
  Serial.printf("Sensor reading: %.2f cm\n", distance);
  
  if (distance > 0) {
    Serial.println("Uploading to Firebase...");
    
    String basePath = "/lab/power_test/cycle_" + String(g_cycle_count);
    
    Database.set<float>(async_client1, basePath + "/distance_cm", distance, processData, "upload_distance");
    Database.set<uint32_t>(async_client1, basePath + "/timestamp_ms", timestamp, dbResult);
    Database.set<uint32_t>(async_client1, basePath + "/stage", 4, dbResult);
    Database.set<uint32_t>(async_client1, "/lab/power_test/latest_cycle", g_cycle_count, dbResult);
    
    uint32_t uploadStart = millis();
    uint32_t lastPrint = 0;
    bool uploadComplete = false;
    
    while (millis() - uploadStart < STAGE_DURATION_MS) {
      app.loop();
      processData(dbResult);
      
      if (!uploadComplete && dbResult.available()) {
        uploadComplete = true;
        Serial.println("Firebase: Upload complete!");
      }
      
      // Time remaining print every 1 second
      if (millis() - lastPrint >= 1000) {
        uint32_t remaining = (STAGE_DURATION_MS - (millis() - uploadStart)) / 1000;
        Serial.printf("Time remaining: %u seconds\n", remaining);
        lastPrint = millis();
      }
      
      delay(50);
    }
    
    if (!uploadComplete) {
      Serial.println("WARNING: Upload may not have completed");
    }
  } else {
    Serial.println("WARNING: No valid sensor reading");
  }
  
  Serial.printf("\nCycle #%u COMPLETE!\n", g_cycle_count);
  g_stage = 0;
  g_cycle_count++;
}

// -------------------- Arduino Entry Points --------------------

void setup() {
  Serial.begin(115200);
  delay(500);
  
  Serial.println("\n\n");
  Serial.println("==========================================");
  Serial.println("  ESP32 Power Management Test System     ");
  Serial.println("  5-Stage Power Mode Cycle                ");
  Serial.println("==========================================");
  
  Serial.printf("Current Stage: %u\n", g_stage);
  Serial.printf("Total Cycles: %u\n", g_cycle_count);
  
  esp_sleep_wakeup_cause_t wakeupReason = esp_sleep_get_wakeup_cause();
  Serial.print("Wakeup Reason: ");
  
  switch (wakeupReason) {
    case ESP_SLEEP_WAKEUP_TIMER:
      Serial.println("Timer (from Deep Sleep)");
      break;
    case ESP_SLEEP_WAKEUP_EXT0:
      Serial.println("External RTC_IO");
      break;
    case ESP_SLEEP_WAKEUP_EXT1:
      Serial.println("External RTC_CNTL");
      break;
    default:
      Serial.println("Power On / Reset");
      break;
  }
  
  Serial.println();
}

void loop() {
  switch (g_stage) {
    case 0:
      stageDeepSleep();
      break;
      
    case 1:
      stageIdle();
      break;
      
    case 2:
      stageUltrasonicOnly();
      break;
      
    case 3:
      stageWiFiNoUltrasonic();
      break;
      
    case 4:
      stageFullOperation();
      break;
      
    default:
      Serial.println("ERROR: Invalid stage, resetting to 0");
      g_stage = 0;
      break;
  }
  
  delay(500);
}